#!/usr/bin/env bash

# THE IDEA:
#
# global : the global file containing default settings
# local  : the local options file for a game instance
# synced : the list of synced options and their most recent synced value. the value here is used to determine if the setting was changed
#
# modes:
#     respect (default): respect locally changed options. if a synced option is changed locally, it will not be overwritten
#     overwrite: overwrites all options the SYNCED file regardless of if it's been changed locally
#
# setup: create a file called sync.txt. this file contains the list of settings (and their initial values) that will be synced between the settings files.
#        this file should contain a subset of options from LOCAL exactly as they are written (`<option>:<value>`).
#
# on game start: read GLOAL, LOCAL, and SYNCED. recreate LOCAL: if synced == local != global: replace local with global, update synced.txt

GLOBAL=./global.txt
LOCAL=./local.txt
SYNCED=./sync.txt

MODE=respect

changed() {
  comm -i13 <(sort "$1") <(sort "$2")
}

declare -A global_options local_options synced_options _seen_options changed_options
declare -a options_order

load_file() {
  local file="$1"
  local -n map="$2"

  while IFS= read line ; do
    IFS=: read -r key val <<< "$line"
    map["$key"]="$val"

    if [[ ! -v _seen_options["$key"] ]] ; then
      options_order+=("$key")
      _seen_options["$key"]=1
    fi

  done < "$file"
}

printmap() {
  local -n map="$1"

  local -a sorted_keys=("${options_order[@]}" "${!map[@]}")

  sorted_keys=($(IFS=$'\n' ; echo "${sorted_keys[*]}" | command cat -n | sort -uk2 | sort -nk1 | cut -f2-))

  for key in "${sorted_keys[@]}" ; do
    [[ -v map["$key"] ]] && printf '%s\n%s\n' "$key" "${map["$key"]}"
  done | paste -d' ' - - | column -t
}

formatoptions() {
  local -n map="$1"

  local -a sorted_keys=("${options_order[@]}" "${!map[@]}" "${!changed_options[@]}")
  sorted_keys=($(IFS=$'\n' ; echo "${sorted_keys[*]}" | command cat -n | sort -uk2 | sort -nk1 | cut -f2-))

  local optionstxt=""

  for key in "${sorted_keys[@]}" ; do
    if [[ -v map["$key"] ]] ; then
      optionstxt+="${key}:${map["$key"]}"
      optionstxt+=$'\n'
    fi
  done

  echo -n "$optionstxt"
}

# creates the sync file but DOES NOT CHANGE options.txt
initcmd() {
  local mode="$1"
  local global_file="$2"
  local sync_file="${3:-./synced-options.txt}"

  case "${mode,,}" in
    # creates an empty sync file
    "empty")
      ;;

    # creates a sync file with every option in synced-options.txt
    "fullclone" | "full-clone")
      load_file "$global_file" global_options
      for key in "${options_order[@]}" ; do
        synced_options["$key"]=""
      done
      ;;
  esac
}

# l == s and s == g -> synced
# l == s and s != g -> unsynced, global changed
# l != s and s == g -> local changed, remove sync
# else -> ambiguous

syncoptions() {
  for opt in "${!synced_options[@]}" ; do
    local s="${synced_options["$opt"]}"
    local l="${local_options["$opt"]}"
    local g="${global_options["$opt"]}"

    if [[ ($MODE == "respect" && $l == $s && $s != $g) || ($MODE == "overwrite" && $l != $g) ]] ; then
      local_options["$opt"]="$g"
      changed_options["$opt"]="$g"
      synced_options["$opt"]="$g"
    else
      unset synced_options["$opt"]
    fi
  done
}

do-sync() {
  load_file "$GLOBAL" global_options
  load_file "$LOCAL" local_options
  load_file "$SYNCED" synced_options
  load_file "$SYNCED" changed_options

  syncoptions

  if [[ ${#synced_options[@]} > 0 ]] ; then
    echo 'The following changes settings will be updated:'
    printmap synced_options

    read -p 'Apply changes? [y/n] ' yn
    if [[ ! "$yn" =~ [Yy] ]] ; then
      return 0
    fi

    echo 'updating local options'
    cp "$LOCAL" "$LOCAL.bak"
    formatoptions local_options | tee "$LOCAL"

    echo 'updating sync file'
    cp "$SYNCED" "$SYNCED.bak"
    formatoptions changed_options | tee "$SYNCED"
  else
    echo 'options.txt is up to date'
  fi
}

do-sync
