#!/usr/bin/env bash

# THE IDEA:
#
# global : the global file containing default settings
# local	: the local options file for a game instance
# synced : the list of synced options and their most recent synced value. the value here is used to determine if the setting was changed
#
# modes:
#		 respect (default): respect locally changed options. if a synced option is changed locally, it will not be overwritten
#		 overwrite: overwrites all options the SYNCED file regardless of if it's been changed locally
#
# setup: create a file called sync.txt. this file contains the list of settings (and their initial values) that will be synced between the settings files.
#				this file should contain a subset of options from LOCAL exactly as they are written (`<option>:<value>`).
#
# on game start: read GLOAL, LOCAL, and SYNCED. recreate LOCAL: if synced == local != global: replace local with global, update synced.txt

GLOBAL=
LOCAL=
SYNCED=

MODE=respect
YES=0
DRY_RUN=0

changed() {
	comm -i13 <(sort "$1") <(sort "$2")
}

declare -A global_options local_options synced_options _seen_options changed_options
declare -a options_order

load_file() {
	local file="$1"
	local -n map="$2"

	while IFS= read line ; do
		IFS=: read -r key val <<< "$line"
		map["$key"]="$val"

		if [[ ! -v _seen_options["$key"] ]] ; then
			options_order+=("$key")
			_seen_options["$key"]=1
		fi

	done < "$file"
}

printmap() {
	local -n map="$1"

	local -a sorted_keys=("${options_order[@]}" "${!map[@]}")

	sorted_keys=($(IFS=$'\n' ; echo "${sorted_keys[*]}" | command cat -n | sort -uk2 | sort -nk1 | cut -f2-))

	for key in "${sorted_keys[@]}" ; do
		[[ -v map["$key"] ]] && printf '%s\n%s\n' "$key" "${map["$key"]}"
	done | paste -d' ' - - | column -t
}

formatoptions() {
	local -n map="$1"

	local -a sorted_keys=("${options_order[@]}" "${!map[@]}" "${!changed_options[@]}")
	sorted_keys=($(IFS=$'\n' ; echo "${sorted_keys[*]}" | command cat -n | sort -uk2 | sort -nk1 | cut -f2-))

	local optionstxt=""

	for key in "${sorted_keys[@]}" ; do
		if [[ -v map["$key"] ]] ; then
			optionstxt+="${key}:${map["$key"]}"
			optionstxt+=$'\n'
		fi
	done

	echo -n "$optionstxt"
}

# l == s and s == g -> synced
# l == s and s != g -> unsynced, global changed
# l != s and s == g -> local changed, remove sync
# else -> ambiguous

syncoptions() {
	for opt in "${!synced_options[@]}" ; do
		local s="${synced_options["$opt"]}"
		local l="${local_options["$opt"]}"
		local g="${global_options["$opt"]}"

		if [[ ($MODE == "respect" && $l == $s && $s != $g) || ($MODE == "overwrite" && $l != $g) ]] ; then
			local_options["$opt"]="$g"
			changed_options["$opt"]="$g"
			synced_options["$opt"]="$g"
		else
			unset synced_options["$opt"]
		fi
	done
}

do-sync() {
	load_file "$GLOBAL" global_options
	load_file "$LOCAL" local_options
	load_file "$SYNCED" synced_options
	load_file "$SYNCED" changed_options

	syncoptions

	if [[ ${#synced_options[@]} -gt 0 ]] ; then
		echo 'The following changes settings will be updated:'
		printmap synced_options

		if [[ $YES != 1 ]] ; then
			read -p 'Apply changes? [y/n] ' yn
			if [[ ! "$yn" =~ [Yy] ]] ; then
				return 0
			fi
		fi

		if [[ $DRY_RUN == 0 ]] ; then
			err
			err 'writing local options'
			cp "$LOCAL" "$LOCAL.bak"
			formatoptions local_options | tee "$LOCAL" >&2

			err
			err 'writing sync file'
			cp "$SYNCED" "$SYNCED.bak"
			formatoptions changed_options | tee "$SYNCED" >&2
		else
			err
			err 'writing local options'
			formatoptions local_options >&2

			err
			err 'writing sync file'
			formatoptions changed_options >&2
		fi
	else
		err "$(basename "$LOCAL") is up to date"
	fi
}

err() {
	echo $@ >&2
}

while getopts ":g:l:s:m:yhn" opt ; do
	case "$opt" in
		g)
			GLOBAL="$OPTARG"
			;;

		l)
			LOCAL="$OPTARG"
			;;

		s)
			SYNCED="$OPTARG"
			;;

		n)
			DRY_RUN=1
			;;

		m)
			if [[ ! "${OPTARG,,}" =~ ^(respect|overwrite) ]] ; then
				err "-m [mode] : mode must be one of: respect, overwrite"
				exit 1
			fi
			MODE="${OPTARG,,}"
			;;

		y)
			YES=1
			;;

		:)
			err "-$OPTARG requires an argument"
			exit 1
			;;

		\?)
			err "invalid option: -$OPTARG"
			exit 1
			;;
	esac
done

shift $((OPTIND-1))

cmd="$1"
shift

opts=("GLOBAL" "LOCAL" "SYNCED")
for arg in ${opts[@]} ; do
	if [[ -z "${!arg}" ]] ; then
		err "missing argument for $arg"
		cmd=help
	fi
done

case "$cmd" in
	sync)
		do-sync
		;;

	"help" | *)
		cat <<- EOH
		Minecraft options.txt sync

		Usage: optsync [options] <sync|help>

		Options:
		    -g <file>                 global options.txt file ($GLOBAL)
		    -l <file>                 local options.txt file ($LOCAL)
		    -s <file>                 sync file ($SYNCED)
		    -m <respect|overwrite>    sync mode ($MODE)
		    -y                        bypass confirmation ($YES)
		    -n                        dry run ($DRY_RUN)
		EOH
		;;

	esac

# vim: noet
